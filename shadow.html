<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo Ray Tracing - Phong Lighting dengan Plane & Inter-Object Shadows</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            font-family: sans-serif;
        }
        canvas {
            border: 1px solid black;
            background-color: white; /* Warna default jika JS gagal */
        }
    </style>
</head>
<body>
    <h1>Demo Ray Tracing Dua Bola & Plane (Phong Lighting + Inter-Object Shadows)</h1>
    <p>Menampilkan dua bola (satu bisa membayangi yang lain) dan sebuah plane dengan pencahayaan Ambient, Diffuse, Specular, dan bayangan.</p>
    <canvas id="rayCanvas" width="500" height="500"></canvas>

    <script>
        // --- Bagian Helper (Vektor) ---
        function add(v1, v2) { return { x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z }; }
        function subtract(v1, v2) { return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z }; }
        function multiplyScalar(v, s) { return { x: v.x * s, y: v.y * s, z: v.z * s }; }
        function dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z; }
        function lengthSquared(v) { return v.x * v.x + v.y * v.y + v.z * v.z; }
        function length(v) { return Math.sqrt(lengthSquared(v)); }
        function normalize(v) {
            const len = length(v);
            if (len === 0) return { x: 0, y: 0, z: 0 };
            return multiplyScalar(v, 1 / len);
        }
        // --- Akhir Bagian Helper Vektor ---

        // --- Bagian Helper (Warna) ---
        function multiplyColors(c1, c2) {
            return { r: c1.r * c2.r, g: c1.g * c2.g, b: c1.b * c2.b };
        }
        function addColors(c1, c2) {
            return { r: c1.r + c2.r, g: c1.g + c2.g, b: c1.b + c2.b };
        }
        function scaleColor(c, s) {
            return { r: c.r * s, g: c.g * s, b: c.b * s };
        }
        function clampColor(c, min = 0, max = 1) {
             return {
                 r: Math.max(min, Math.min(max, c.r)),
                 g: Math.max(min, Math.min(max, c.g)),
                 b: Math.max(min, Math.min(max, c.b))
             };
        }
        // --- Akhir Bagian Helper Warna ---


        // --- Bagian Script Utama ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('rayCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            const epsilon = 0.0001; 

            // --- Definisi Scene ---
            const camera = {
                origin: { x: 0, y: 0.5, z: -4 }, 
            };

            const light = {
                direction: normalize({ x: 0.5, y: -0.6, z: -1.0 }), // Cahaya agak dari kanan atas depan
                color: { r: 1.0, g: 1.0, b: 1.0 }
            };
            const ambientLight = { r: 0.15, g: 0.15, b: 0.15 };

            // Bola 1 (Merah) - akan menerima bayangan dari bola biru
            const sphere1 = {
                type: 'sphere',
                center: { x: 0.2, y: -0.1, z: -1.2 }, // Sedikit ke kanan, bawah, dan lebih jauh
                radius: 0.4,
                material: {
                    diffuseColor: { r: 1.0, g: 0.2, b: 0.2 },
                    specularColor: { r: 1.0, g: 1.0, b: 1.0 },
                    shininess: 32
                }
            };

            // Bola 2 (Biru) - akan membayangi bola merah
            const sphere2 = {
                type: 'sphere',
                center: { x: -0.4, y: 0.3, z: -2.0 }, // Ke kiri, atas, dan paling jauh (relatif terhadap arah cahaya akan berada di depan sphere1)
                radius: 0.3,
                material: {
                    diffuseColor: { r: 0.2, g: 0.2, b: 1.0 },
                    specularColor: { r: 1.0, g: 1.0, b: 1.0 },
                    shininess: 64
                }
            };
             // Untuk melihat sphere2 membayangi sphere1 dengan light.direction {x:0.5, y:-0.6, z:-1.0}
             // Artinya cahaya datang dari arah (-0.5, 0.6, 1.0) menuju origin.
             // Kita ingin sphere2 berada "di antara" sumber cahaya dan sphere1.
             // sphere2.center: { x: sphere1.center.x - light.direction.x * 0.8, y: sphere1.center.y - light.direction.y * 0.8, z: sphere1.center.z - light.direction.z * 0.8}
             // sphere2.center: { x: 0.2 - 0.5*0.8, y: -0.1 - (-0.6*0.8), z: -1.2 - (-1.0*0.8)}
             // sphere2.center: { x: 0.2 - 0.4, y: -0.1 + 0.48, z: -1.2 + 0.8}
             // sphere2.center: { x: -0.2, y: 0.38, z: -0.4 } // Ini akan menempatkan sphere2 lebih dekat ke kamera
            
            // Posisi baru agar Sphere 2 (Biru) jelas membayangi Sphere 1 (Merah)
            // Sphere 1 (Merah) - target bayangan
            sphere1.center = { x: 0.3, y: -0.1, z: -1.0 };
            sphere1.radius = 0.5;

            // Sphere 2 (Biru) - pemberi bayangan
            // Ditempatkan "di depan" sphere1 relatif terhadap arah cahaya
            // Arah cahaya L = (0.5, -0.6, -1.0)
            // Sphere2 center = Sphere1.center - L_normalized * distance_along_light_ray
            // Untuk simple: geser sphere2 ke arah (-Lx, +Ly, +Lz) dari sphere1
            sphere2.center = { x: sphere1.center.x - 0.4, // Lebih ke kiri (berlawanan arah X cahaya)
                               y: sphere1.center.y + 0.4, // Lebih ke atas (berlawanan arah Y cahaya)
                               z: sphere1.center.z + 0.6}; // Lebih dekat ke kamera (berlawanan arah Z cahaya)
            sphere2.radius = 0.25;


            const floorPlane = {
                type: 'plane',
                point: { x: 0, y: -0.6, z: 0 }, // Turunkan sedikit plane
                normal: normalize({ x: 0, y: 1, z: 0 }), 
                material: {
                    color1: { r: 0.8, g: 0.8, b: 0.8 }, 
                    color2: { r: 0.2, g: 0.2, b: 0.2 }, 
                    specularColor: { r: 0.1, g: 0.1, b: 0.1 }, 
                    shininess: 10,
                    isCheckerboard: true,
                    checkerScale: 1.5 // Ubah skala checkerboard jika perlu
                }
            };

            const sceneObjects = [sphere1, sphere2, floorPlane];
            const backgroundColor = { r: 135, g: 206, b: 250 };

            function intersectSphere(rayOrigin, rayDirection, sphere) {
                const oc = subtract(rayOrigin, sphere.center);
                const a = dot(rayDirection, rayDirection);
                const b = 2.0 * dot(oc, rayDirection);
                const c = dot(oc, oc) - sphere.radius * sphere.radius;
                const discriminant = b * b - 4 * a * c;

                if (discriminant < 0) {
                    return null;
                } else {
                    const t1 = (-b - Math.sqrt(discriminant)) / (2.0 * a);
                    const t2 = (-b + Math.sqrt(discriminant)) / (2.0 * a);
                    if (t1 > epsilon && (t2 <= epsilon || t1 < t2)) return t1;
                    if (t2 > epsilon) return t2;
                    return null;
                }
            }

            function intersectPlane(rayOrigin, rayDirection, plane) {
                const denominator = dot(rayDirection, plane.normal);
                if (Math.abs(denominator) < epsilon) {
                    return null;
                }
                const t = dot(subtract(plane.point, rayOrigin), plane.normal) / denominator;
                return (t > epsilon) ? t : null;
            }

            function render() {
                const imageData = ctx.createImageData(width, height);
                const data = imageData.data;

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const viewportX = (2 * (x + 0.5) / width - 1.0) * (width / height); 
                        const viewportY = (1.0 - 2 * (y + 0.5) / height);
                        const pixelPosWorld = { x: viewportX, y: viewportY, z: camera.origin.z + 1 }; 
                        const rayDirection = normalize(subtract(pixelPosWorld, camera.origin));

                        let closestT = Infinity;
                        let hitObject = null;

                        for (const object of sceneObjects) {
                            let t = null;
                            if (object.type === 'sphere') {
                                t = intersectSphere(camera.origin, rayDirection, object);
                            } else if (object.type === 'plane') {
                                t = intersectPlane(camera.origin, rayDirection, object);
                            }

                            if (t !== null && t < closestT) {
                                closestT = t;
                                hitObject = object;
                            }
                        }

                        let finalColor = backgroundColor;

                        if (hitObject !== null) {
                            const material = hitObject.material;
                            const hitPoint = add(camera.origin, multiplyScalar(rayDirection, closestT));
                            
                            let surfaceNormal;
                            let actualDiffuseColor;

                            if (hitObject.type === 'sphere') {
                                surfaceNormal = normalize(subtract(hitPoint, hitObject.center));
                                actualDiffuseColor = material.diffuseColor;
                            } else if (hitObject.type === 'plane') {
                                surfaceNormal = hitObject.normal;
                                if (material.isCheckerboard) {
                                    const u = Math.floor(hitPoint.x * material.checkerScale + 1000.5); // +1000.5 to avoid negative issues with floor
                                    const v = Math.floor(hitPoint.z * material.checkerScale + 1000.5);
                                    if ((u + v) % 2 === 0) {
                                        actualDiffuseColor = material.color1;
                                    } else {
                                        actualDiffuseColor = material.color2;
                                    }
                                } else {
                                    actualDiffuseColor = material.diffuseColor; 
                                }
                            }

                            const viewDir = normalize(subtract(camera.origin, hitPoint));
                            const lightDir = light.direction; 

                            // --- Shadow Calculation ---
                            let shadowFactor = 1.0; 
                            const shadowRayOrigin = add(hitPoint, multiplyScalar(surfaceNormal, epsilon * 10)); 
                            const shadowRayDirection = lightDir; 

                            for (const otherObject of sceneObjects) {
                                // PENTING: Jangan periksa interseksi dengan objek itu sendiri
                                if (otherObject === hitObject) {
                                    continue;
                                }

                                let tShadow = null;
                                if (otherObject.type === 'sphere') {
                                    tShadow = intersectSphere(shadowRayOrigin, shadowRayDirection, otherObject);
                                } else if (otherObject.type === 'plane') {
                                    tShadow = intersectPlane(shadowRayOrigin, shadowRayDirection, otherObject);
                                }
                                
                                if (tShadow !== null && tShadow > epsilon) {
                                    shadowFactor = 0.2; 
                                    break; 
                                }
                            }
                            // --- End Shadow Calculation ---

                            const ambient = multiplyColors(ambientLight, actualDiffuseColor);
                            
                            const diffuseIntensity = Math.max(0.0, dot(surfaceNormal, lightDir));
                            const diffuse = scaleColor(multiplyColors(light.color, actualDiffuseColor), diffuseIntensity * shadowFactor);

                            const halfwayDir = normalize(add(lightDir, viewDir));
                            const specAngle = Math.max(0.0, dot(surfaceNormal, halfwayDir));
                            const specularIntensity = Math.pow(specAngle, material.shininess);
                            const specular = scaleColor(multiplyColors(light.color, material.specularColor), specularIntensity * shadowFactor);

                            let combinedColor = addColors(ambient, addColors(diffuse, specular));
                            combinedColor = clampColor(combinedColor, 0.0, 1.0);

                            finalColor = {
                                r: Math.floor(combinedColor.r * 255),
                                g: Math.floor(combinedColor.g * 255),
                                b: Math.floor(combinedColor.b * 255)
                            };
                        }

                        const index = (y * width + x) * 4;
                        data[index]     = finalColor.r;
                        data[index + 1] = finalColor.g;
                        data[index + 2] = finalColor.b;
                        data[index + 3] = 255;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                console.log("Rendering complete.");
            }

            render();
        });
    </script>
</body>
</html>